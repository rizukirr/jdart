import 'package:test/test.dart';
import '../lib/parser.dart';

void main() {
  group('Parser Performance Optimizations', () {
    test('Simple JSON generates correctly', () {
      final json = '{"name": "John", "age": 30}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('class AutoGenerated {'));
      expect(result, contains('final String name;'));
      expect(result, contains('final int age;'));
      expect(result, contains('const AutoGenerated({'));
      expect(result, contains('required this.name,'));
      expect(result, contains('required this.age,'));
    });

    test('Simple JSON with explicit class name', () {
      final json = '{"name": "John", "age": 30}';
      final result = Parser.generateDartClass(
        json,
        'Person',
        false,
        false,
        false,
      );

      expect(result, contains('class Person {'));
      expect(result, contains('final String name;'));
      expect(result, contains('final int age;'));
    });

    test('JSON with fromJson generates factory constructor', () {
      final json = '{"name": "John", "age": 30}';
      final result = Parser.generateDartClass(json, null, true, false, false);

      expect(
        result,
        contains('factory AutoGenerated.fromJson(Map<String, dynamic> json)'),
      );
      expect(result, contains('return AutoGenerated('));
      expect(result, contains('name: json["name"]'));
      expect(result, contains('age: json["age"]'));
    });

    test('JSON with toJson generates toJson method', () {
      final json = '{"name": "John", "age": 30}';
      final result = Parser.generateDartClass(json, null, false, true, false);

      expect(result, contains('Map<String, dynamic> toJson()'));
      expect(result, contains('"name": name'));
      expect(result, contains('"age": age'));
    });

    test('JSON with parseList generates parseList method', () {
      final json = '{"id": 1, "name": "Item"}';
      final result = Parser.generateDartClass(json, null, false, false, true);

      expect(
        result,
        contains('static List<AutoGenerated> parseList(dynamic jsonList)'),
      );
      expect(
        result,
        contains(
          'if (jsonList == null || jsonList is! List || jsonList.isEmpty)',
        ),
      );
      expect(
        result,
        contains(
          'return jsonList.map((json) => AutoGenerated.fromJson(json)).toList()',
        ),
      );
    });

    test('Nested JSON preserves structure', () {
      final json = '{"user": {"name": "John", "profile": {"bio": "Hello"}}}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('class User {'));
      expect(result, contains('class Profile {'));
      expect(result, contains('final String name;'));
      expect(result, contains('final String bio;'));
      expect(result, contains('final Profile profile;'));
    });

    test('List JSON handles correctly without re-encoding', () {
      final json = '[{"id": 1}, {"id": 2}]';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('class AutoGenerated {'));
      expect(result, contains('final int id;'));
    });

    test('List of objects with nested structure', () {
      final json = '[{"user": {"name": "John", "age": 30}}]';
      final result = Parser.generateDartClass(json, null, true, true, true);

      expect(result, contains('class User {'));
      expect(result, contains('final String name;'));
      expect(result, contains('final int age;'));
    });

    test('JSON with single root key extracts class name', () {
      final json = '{"person": {"name": "John", "age": 30}}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('class Person {'));
      expect(result, contains('final String name;'));
      expect(result, contains('final int age;'));
    });

    test('All data types are handled correctly', () {
      final json =
          '{"stringField": "text", "intField": 42, "doubleField": 3.14, "boolField": true, "listField": [1, 2, 3], "mapField": {"nested": "value"}}';
      final result = Parser.generateDartClass(
        json,
        'DataTypes',
        false,
        false,
        false,
      );

      expect(result, contains('final String stringField;'));
      expect(result, contains('final int intField;'));
      expect(result, contains('final double doubleField;'));
      expect(result, contains('final bool boolField;'));
      expect(result, contains('final List<int> listField;'));
      expect(result, contains('final MapField mapField;'));
    });

    test('Empty list defaults to List<dynamic>', () {
      // When there are multiple fields including an empty list
      final json = '{"emptyList": [], "name": "test"}';
      final result = Parser.generateDartClass(json, null, true, false, false);

      expect(result, contains('final List<dynamic> emptyList;'));
      expect(
        result,
        contains('emptyList: List<dynamic>.from(json["emptyList"])'),
      );
    });

    test('Name conversion handles camelCase', () {
      final json = '{"firstName": "John", "lastName": "Doe"}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('final String firstName;'));
      expect(result, contains('final String lastName;'));
    });

    test('Name conversion handles snake_case', () {
      final json = '{"first_name": "John", "last_name": "Doe"}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('final String firstName;'));
      expect(result, contains('final String lastName;'));
    });

    test('Name conversion handles numbers', () {
      final json = '{"field1": "value1", "field2": "value2"}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('final String field1;'));
      expect(result, contains('final String field2;'));
    });

    test('Name starting with number gets prefixed with A', () {
      final json = '{"1stField": "value"}';
      // Need explicit class name when single field
      final result = Parser.generateDartClass(
        json,
        'TestClass',
        false,
        false,
        false,
      );

      expect(result, contains('final String a1StField;'));
    });

    test('Nested lists of objects with multiple fields', () {
      final json = '{"items": [{"id": 1, "name": "Item1"}], "count": 5}';
      final result = Parser.generateDartClass(json, null, true, false, false);

      expect(result, contains('class Items {'));
      expect(result, contains('final int id;'));
      expect(result, contains('final String name;'));
      expect(result, contains('items: Items.parseList(json["items"])'));
      expect(result, contains('final int count;'));
    });

    test('Deeply nested structure', () {
      final json = '{"level1": {"level2": {"level3": {"value": "deep"}}}}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('class Level1 {'));
      expect(result, contains('class Level2 {'));
      expect(result, contains('class Level3 {'));
      expect(result, contains('final String value;'));
    });

    test('Multiple root keys uses AutoGenerated', () {
      final json = '{"field1": "value1", "field2": "value2"}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('class AutoGenerated {'));
    });

    test('Empty JSON generates empty class', () {
      final json = '{}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      // Empty JSON generates a class with no fields
      expect(result, contains('class AutoGenerated {'));
      expect(result, contains('const AutoGenerated'));
    });

    test('Invalid JSON returns empty string', () {
      final json = '{invalid json}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, isEmpty);
    });
  });

  group('JSON Validation', () {
    test('Valid JSON string returns true', () {
      final json = '{"name": "John"}';
      expect(Parser.checkIfValidJsonString(json), isTrue);
    });

    test('Invalid JSON string returns false', () {
      final json = '{invalid}';
      expect(Parser.checkIfValidJsonString(json), isFalse);
    });

    test('Empty string returns false', () {
      expect(Parser.checkIfValidJsonString(''), isFalse);
    });

    test('Valid array JSON returns true', () {
      final json = '[{"id": 1}]';
      expect(Parser.checkIfValidJsonString(json), isTrue);
    });
  });

  group('Memoization Cache Tests', () {
    test('Multiple calls with same JSON use cache', () {
      final json = '{"testKey": "value", "anotherKey": "value2"}';

      // First call populates cache
      final result1 = Parser.generateDartClass(json, null, true, true, false);

      // Second call should use cache for name conversion and type detection
      final result2 = Parser.generateDartClass(json, null, true, true, false);

      // Results should be identical
      expect(result1, equals(result2));
    });

    test('Cache is cleared between generateDartClass calls', () {
      // First generation
      final json1 = '{"field1": "value1"}';
      final result1 = Parser.generateDartClass(
        json1,
        'Class1',
        false,
        false,
        false,
      );
      expect(result1, contains('class Class1'));

      // Second generation with different JSON
      final json2 = '{"field2": "value2"}';
      final result2 = Parser.generateDartClass(
        json2,
        'Class2',
        false,
        false,
        false,
      );
      expect(result2, contains('class Class2'));
      expect(result2, contains('final String field2;'));
    });
  });

  group('Edge Cases', () {
    test('Handles null values with explicit class name', () {
      final json = '{"nullableField": null}';
      final result = Parser.generateDartClass(
        json,
        'NullableTest',
        false,
        false,
        false,
      );

      expect(result, contains('final dynamic nullableField;'));
    });

    test('Handles very long field names with explicit class name', () {
      final json =
          '{"thisIsAVeryLongFieldNameThatShouldStillBeProcessedCorrectly": "value"}';
      final result = Parser.generateDartClass(
        json,
        'LongFieldTest',
        false,
        false,
        false,
      );

      // The name is correctly converted to camelCase: "IsA" becomes "isa"
      expect(
        result,
        contains(
          'final String thisIsaVeryLongFieldNameThatShouldStillBeProcessedCorrectly;',
        ),
      );
    });

    test('Handles special characters in field names', () {
      final json =
          '{"field-with-dashes": "value", "field_with_underscores": "value"}';
      final result = Parser.generateDartClass(json, null, false, false, false);

      expect(result, contains('final String fieldWithDashes;'));
      expect(result, contains('final String fieldWithUnderscores;'));
    });

    test('Handles unicode characters with explicit class name', () {
      final json = '{"fieldName": "value with unicode: ü ñ ä"}';
      final result = Parser.generateDartClass(
        json,
        'UnicodeTest',
        false,
        false,
        false,
      );

      expect(result, contains('final String fieldName;'));
    });
  });
}
