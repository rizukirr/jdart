import 'dart:convert';

// Helper class to store precomputed field information for single-pass generation
class _FieldInfo {
  final String originalKey;
  final String variableName;
  final String dartType;
  final String fromJsonMapper;
  final String toJsonMapper;

  _FieldInfo({
    required this.originalKey,
    required this.variableName,
    required this.dartType,
    required this.fromJsonMapper,
    required this.toJsonMapper,
  });
}

class Parser {
  // Memoization caches for performance optimization
  static final Map<String, String> _classNameCache = {};
  static final Map<String, String> _variableNameCache = {};
  static final Map<String, String> _typeCache = {};

  // Compiled regex patterns for performance
  static final _upperCasePattern = RegExp(r'[A-Z]');
  static final _digitPattern = RegExp(r'[0-9]');
  static final _nonAlphanumPattern = RegExp(r'[^a-zA-Z0-9]');
  static final _leadingDigitPattern = RegExp(r'^[0-9]');

  static bool checkIfValidJsonString(String jsonString) {
    try {
      jsonDecode(jsonString);
      return true;
    } catch (_) {
      return false;
    }
  }

  static String generateDartClass(
    dynamic jsonInput,
    String? className,
    bool fromJson,
    bool toJson,
    bool parseList,
  ) {
    // Clear memoization caches at start of each generation
    _classNameCache.clear();
    _variableNameCache.clear();
    _typeCache.clear();

    try {
      // Parse only if string, otherwise use directly
      dynamic jsonData = jsonInput is String
          ? jsonDecode(jsonInput)
          : jsonInput;

      // If className is null or empty, try to extract from root JSON key
      if (className == null || className.trim().isEmpty) {
        if (jsonData is Map<String, dynamic>) {
          if (jsonData.length == 1) {
            // Single root key - use it as className and unwrap the JSON
            final rootKey = jsonData.keys.first;
            className = rootKey;
            jsonData = jsonData[rootKey];

            // Validate that unwrapped data is also a Map
            if (jsonData is! Map<String, dynamic>) {
              return "";
            }
          } else if (jsonData.isEmpty) {
            // Empty JSON - use fallback
            className = "AutoGenerated";
          } else {
            // Multiple root keys - use fallback
            className = "AutoGenerated";
          }
        } else if (jsonData is List) {
          // Root is a list - use fallback
          className = "AutoGenerated";
        } else {
          // Primitive value - use fallback
          className = "AutoGenerated";
        }
      }

      if (jsonData is Map<String, dynamic>) {
        final Map<String, Map<String, dynamic>> nestedMaps =
            _extractNestedMapFromMap(className, jsonData);
        return nestedMaps.entries
            .map(
              (entry) => _generateClassFromMap(
                entry.value,
                entry.key,
                fromJson,
                toJson,
                parseList,
              ),
            )
            .join("\n\n");
      } else if (jsonData is List) {
        if (jsonData.isNotEmpty) {
          // Pass data directly without re-encoding
          return generateDartClass(
            jsonData[0],
            className,
            fromJson,
            toJson,
            parseList,
          );
        }
      }
    } catch (_) {}
    return "";
  }

  static Map<String, Map<String, dynamic>> _extractNestedMapFromMap(
    String className,
    Map<String, dynamic> map,
  ) {
    final Map<String, Map<String, dynamic>> nestedMaps = {};
    nestedMaps[_convertToValidClassName(className)] = map;
    map.forEach((key, value) {
      if (value is Map<String, dynamic>) {
        nestedMaps.addAll(_extractNestedMapFromMap(key, value));
      } else if (value is List &&
          value.isNotEmpty &&
          value.first is Map<String, dynamic>) {
        nestedMaps.addAll(_extractNestedMapFromMap(key, value.first));
      }
    });
    return nestedMaps;
  }

  static String _generateClassFromMap(
    Map<String, dynamic> jsonMap,
    String className,
    bool fromJson,
    bool toJson,
    bool parseList,
  ) {
    className = getClassName(className);

    // SINGLE pass to compute all field information
    final List<_FieldInfo> fields = jsonMap.entries.map((entry) {
      final key = entry.key;
      final value = entry.value;
      return _FieldInfo(
        originalKey: key,
        variableName: _convertToValidVariableName(key),
        dartType: _getDartType(key, value),
        fromJsonMapper: _convertFromJsonMapper(key, value),
        toJsonMapper: _convertToJsonMapper(key, value),
      );
    }).toList();

    // Use precomputed data to build each section
    StringBuffer classBuffer = StringBuffer();
    classBuffer.writeln("class $className {");

    // Field declarations
    for (var field in fields) {
      classBuffer.writeln(" final ${field.dartType} ${field.variableName};");
    }
    classBuffer.writeln("");

    // Constructor
    classBuffer.writeln("const $className({");
    for (var field in fields) {
      classBuffer.writeln("   required this.${field.variableName},");
    }
    classBuffer.writeln(" });");
    classBuffer.writeln("");

    // fromJson (if enabled)
    if (fromJson) {
      classBuffer.writeln(
        " factory $className.fromJson(Map<String, dynamic> json) {",
      );
      classBuffer.writeln("   return $className(");
      for (var field in fields) {
        classBuffer.writeln(
          "     ${field.variableName}: ${field.fromJsonMapper},",
        );
      }
      classBuffer.writeln("   );");
      classBuffer.writeln(" }");
      classBuffer.writeln("");
    }

    // toJson (if enabled)
    if (toJson) {
      classBuffer.writeln(" Map<String, dynamic> toJson() {");
      classBuffer.writeln("   return {");
      for (var field in fields) {
        classBuffer.writeln(
          "     \"${field.originalKey}\": ${field.toJsonMapper},",
        );
      }
      classBuffer.writeln("   };");
      classBuffer.writeln(" }");
      classBuffer.writeln();
    }

    // parseList (if enabled)
    if (parseList) {
      classBuffer.writeln(
        " static List<$className> parseList(dynamic jsonList) {",
      );
      classBuffer.writeln(
        "   if (jsonList == null || jsonList is! List || jsonList.isEmpty) {",
      );
      classBuffer.writeln("     return [];");
      classBuffer.writeln("   }");
      classBuffer.writeln(
        "   return jsonList.map((json) => $className.fromJson(json)).toList();",
      );
      classBuffer.writeln(" }");
    }

    classBuffer.writeln("}");
    return classBuffer.toString();
  }

  static String _convertFromJsonMapper(String key, dynamic value) {
    if (value is Map) {
      return "${_convertToValidClassName(key)}.fromJson(json[\"$key\"])";
    } else if (value is List) {
      if (value.isEmpty) {
        return "List<dynamic>.from(json[\"$key\"])";
      } else {
        return _convertFromJsonListMapper(key, value[0]);
      }
    } else {
      return "json[\"$key\"]";
    }
  }

  static String _convertToJsonMapper(String key, dynamic value) {
    if (value is Map) {
      return "${_convertToValidVariableName(key)}.toJson()";
    } else if (value is List) {
      if (value.isEmpty) {
        return _convertToValidVariableName(key);
      } else {
        return _convertToJsonListMapper(key, value[0]);
      }
    } else {
      return _convertToValidVariableName(key);
    }
  }

  static String _convertFromJsonListMapper(String key, dynamic value) {
    if (value is Map) {
      return "${_convertToValidClassName(key)}.parseList(json[\"$key\"])";
    } else {
      return "List<${_getDartType(key, value)}>.from(json[\"$key\"])";
    }
  }

  static String _convertToJsonListMapper(String key, dynamic value) {
    if (value is Map) {
      return "${_convertToValidVariableName(key)}.map((e) => e.toJson()).toList()";
    } else {
      return _convertToValidVariableName(key);
    }
  }

  static String _getDartType(String key, dynamic value) {
    // Create cache key from both key and value type
    final cacheKey =
        '$key:${value.runtimeType}:${value is List && value.isNotEmpty ? value[0].runtimeType : ''}';
    return _typeCache.putIfAbsent(cacheKey, () {
      if (value is String) {
        return "String";
      } else if (value is int) {
        return "int";
      } else if (value is double) {
        return "double";
      } else if (value is bool) {
        return "bool";
      } else if (value is Map) {
        return _convertToValidClassName(key);
      } else if (value is List) {
        return "List<${value.isEmpty ? "dynamic" : _getDartType(key, value[0])}>";
      } else {
        return "dynamic";
      }
    });
  }

  static String _convertToValidClassName(String input) {
    return _classNameCache.putIfAbsent(input, () {
      if (input.isEmpty) return input;

      // Use StringBuffer for efficient building
      final buffer = StringBuffer();

      for (int i = 0; i < input.length; i++) {
        final char = input[i];
        if (_upperCasePattern.hasMatch(char)) {
          if (i > 0) buffer.write(' ');
          buffer.write(char.toLowerCase());
        } else if (_digitPattern.hasMatch(char)) {
          buffer.write(char);
          if (i < input.length - 1) buffer.write(' ');
        } else if (_nonAlphanumPattern.hasMatch(char)) {
          buffer.write(' ');
        } else {
          buffer.write(char);
        }
      }

      String processed = buffer.toString().trim();
      if (processed.isEmpty) return processed;

      // PascalCase conversion
      final result = processed
          .split(" ")
          .where((e) => e.isNotEmpty)
          .map(
            (e) => e.length < 2
                ? e.toLowerCase()
                : ("${e[0].toUpperCase()}${e.substring(1).toLowerCase()}"),
          )
          .join();

      return _leadingDigitPattern.hasMatch(result) ? "A$result" : result;
    });
  }

  static String _convertToValidVariableName(String input) {
    return _variableNameCache.putIfAbsent(input, () {
      final className = _convertToValidClassName(input);
      return className.length < 2
          ? className.toLowerCase()
          : ("${className[0].toLowerCase()}${className.substring(1)}");
    });
  }

  static String convertToValidFileName(String input) {
    input = _convertToValidVariableName(input);
    return input.replaceAllMapped(
      RegExp(r'[A-Z0-9]'),
      (match) => '_${match.group(0)!.toLowerCase()}',
    );
  }

  static String getClassName(String className) {
    return className.trim().isEmpty ? "AutoGenerated" : className;
  }
}
